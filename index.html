<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TURBO RACING DAY</title>
    <link href="https://fonts.googleapis.com/css2?family=Racing+Sans+One&family=Roboto:wght@500&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --primary: #ff4400;
            --accent: #ffcc00;
            --panel: rgba(255, 255, 255, 0.9);
            --text: #333;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            overflow: hidden;
            background: #87CEEB;
            /* Sky Blue */
            font-family: 'Roboto', sans-serif;
            color: var(--text);
        }

        canvas {
            display: block;
            outline: none;
        }

        /* UI LAYERS */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        /* MAIN MENU */
        #main-menu {
            background: var(--panel);
            padding: 60px 80px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            pointer-events: auto;
            text-align: center;
        }

        h1 {
            font-family: 'Racing Sans One', cursive;
            font-size: 72px;
            color: var(--primary);
            text-transform: uppercase;
            font-style: italic;
            margin-bottom: 10px;
            text-shadow: 2px 2px 0px #fff, 4px 4px 0px rgba(0, 0, 0, 0.1);
        }

        p.subtitle {
            color: #666;
            margin-bottom: 40px;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .car-select {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
            justify-content: center;
        }

        .car-option {
            background: #f0f0f0;
            border: 4px solid #ddd;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: 0.2s;
            width: 140px;
        }

        .car-option:hover,
        .car-option.selected,
        .track-option:hover,
        .track-option.selected {
            background: #fff;
            border-color: var(--primary);
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .track-select {
            display: flex;
            gap: 15px;
            margin-bottom: 40px;
            justify-content: center;
        }

        .track-option {
            background: #f0f0f0;
            border: 3px solid #ddd;
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: 0.2s;
            width: 160px;
            text-align: center;
        }

        .track-thumb {
            width: 100%;
            height: 60px;
            border-radius: 8px;
            margin-bottom: 10px;
            background-size: cover;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .car-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 15px;
            border: 3px solid rgba(0, 0, 0, 0.1);
        }

        .car-name {
            font-family: 'Racing Sans One';
            font-size: 18px;
            color: #333;
            margin-bottom: 5px;
        }

        .car-stats {
            font-size: 12px;
            color: #888;
        }

        .btn-play {
            background: var(--primary);
            color: white;
            border: none;
            padding: 16px 60px;
            font-family: 'Racing Sans One';
            font-size: 28px;
            border-radius: 50px;
            cursor: pointer;
            transition: 0.2s;
            text-transform: uppercase;
            box-shadow: 0 6px 0 #cc3300;
        }

        .btn-play:hover {
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 8px 0 #cc3300;
        }

        .btn-play:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            padding: 0 40px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-family: 'Racing Sans One';
            z-index: 15;
            text-transform: uppercase;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 15px;
            border-left: 6px solid #ffcc00;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
        }

        .data-label {
            font-size: 16px;
            color: #ffcc00;
            display: block;
            letter-spacing: 2px;
            font-weight: 500;
        }

        .data-value {
            font-size: 48px;
            font-weight: 900;
            line-height: 1;
        }

        #speedometer {
            text-align: right;
        }

        #countdown {
            font-family: 'Racing Sans One';
            font-size: 180px;
            font-weight: 900;
            color: #fff;
            text-shadow: 5px 5px 0 #000;
            stroke: 2px black;
        }

        #game-over-panel {
            background: white;
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
            border: 5px solid var(--primary);
            pointer-events: auto;
        }

        .result-title {
            font-family: 'Racing Sans One';
            font-size: 64px;
            margin-bottom: 10px;
            color: #333;
        }

        .result-msg {
            color: #666;
            margin-bottom: 30px;
            font-size: 20px;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <!-- MENU -->
        <div id="menu-layer" class="ui-layer">
            <div id="main-menu">
                <h1>TURBO RACING</h1>
                <p class="subtitle">PRO CIRCUIT EDITION</p>

                <div class="car-select">
                    <div class="car-option selected" id="car-0" onclick="selectCar(0)">
                        <div class="car-preview" style="background: #ff4444;"></div>
                        <div class="car-name">RED FIRE</div>
                        <div class="car-stats">BALANCED</div>
                    </div>
                    <div class="car-option" id="car-1" onclick="selectCar(1)">
                        <div class="car-preview" style="background: #4488ff;"></div>
                        <div class="car-name">BLUE JET</div>
                        <div class="car-stats">HIGH SPEED</div>
                    </div>
                    <div class="car-option" id="car-2" onclick="selectCar(2)">
                        <div class="car-preview" style="background: #222;"></div>
                        <div class="car-name">SHADOW</div>
                        <div class="car-stats">HANDLING</div>
                    </div>
                </div>

                <p style="margin-bottom: 15px; font-weight: bold; color: #555;">CHOOSE TRACK</p>
                <div class="track-select">
                    <div class="track-option selected" id="track-0" onclick="selectTrack(0)">
                        <div class="track-thumb" style="background: linear-gradient(45deg, #44aa44, #87CEEB);"></div>
                        <div class="car-name" style="font-size: 14px;">SUNNY HILLS</div>
                    </div>
                    <div class="track-option" id="track-1" onclick="selectTrack(1)">
                        <div class="track-thumb" style="background: linear-gradient(45deg, #e29a58, #ff8c00);"></div>
                        <div class="car-name" style="font-size: 14px;">DESERT CANYON</div>
                    </div>
                    <div class="track-option" id="track-2" onclick="selectTrack(2)">
                        <div class="track-thumb" style="background: linear-gradient(45deg, #222, #9900ff);"></div>
                        <div class="car-name" style="font-size: 14px;">NIGHT CITY</div>
                    </div>
                </div>

                <button class="btn-play" onclick="startGame()">START RACE</button>
            </div>
        </div>

        <!-- PLAY HUD -->
        <div id="hud" style="display: none;">
            <div class="hud-panel">
                <span class="data-label">POS</span>
                <span class="data-value" id="hud-pos">1/6</span>
            </div>

            <div class="hud-panel" style="position:absolute; left:50%; transform:translateX(-50%);">
                <span class="data-label">LAP</span>
                <span class="data-value" id="hud-lap">1/3</span>
            </div>

            <div class="hud-panel" id="speedometer">
                <span class="data-label">SPEED</span>
                <span class="data-value" id="hud-speed">0</span>
                <span style="font-size: 20px;"> KM/H</span>
            </div>
        </div>

        <!-- COUNTDOWN -->
        <div id="countdown-layer" class="ui-layer" style="display: none;">
            <div id="countdown">3</div>
        </div>

        <!-- GAME OVER -->
        <div id="game-over-layer" class="ui-layer" style="display: none;">
            <div id="game-over-panel">
                <div class="result-title" id="end-title">FIN DE CARRERA</div>
                <div class="result-msg" id="end-msg">Calculando resultados...</div>
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button class="btn-play" onclick="location.reload()">VOLVER A JUGAR</button>
                </div>
            </div>
        </div>
    </div>

    <!-- AUDIO (Optional) -->
    <!-- <audio id="bgm" src="..." loop></audio> -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        /**
         * ENGINE CONFIG
         */
        const CONFIG = {
            trackRadius: 400,
            trackWidth: 20,
            laps: 3,
            aiCount: 5
        };

        const TRACKS = [
            {
                name: "SUNNY HILLS",
                sky: 0x87CEEB,
                ground: 0x44aa44,
                fog: 0x87CEEB,
                treeColor: 0x228822,
                asphalt: '#555',
                pts: (r) => {
                    const p = [];
                    for (let i = 0; i < 24; i++) {
                        const t = (i / 24) * Math.PI * 2;
                        const x = Math.cos(t) * r + Math.sin(t * 3) * 60;
                        const z = Math.sin(t) * r + Math.cos(t * 2) * 100;
                        const y = Math.sin(t * 4) * 8;
                        p.push(new THREE.Vector3(x, y, z));
                    }
                    return p;
                }
            },
            {
                name: "DESERT CANYON",
                sky: 0xffa500,
                ground: 0xd2b48c,
                fog: 0xffa500,
                treeColor: 0x8b4513,
                asphalt: '#443322',
                pts: (r) => {
                    const p = [];
                    for (let i = 0; i < 24; i++) {
                        const t = (i / 24) * Math.PI * 2;
                        const x = Math.cos(t) * (r * 1.2) + Math.sin(t * 5) * 120;
                        const z = Math.sin(t) * (r * 0.8) + Math.cos(t * 3) * 150;
                        const y = Math.sin(t * 2) * 20 + (i % 2 === 0 ? 5 : -5);
                        p.push(new THREE.Vector3(x, y, z));
                    }
                    return p;
                }
            },
            {
                name: "NIGHT CITY",
                sky: 0x050510,
                ground: 0x111111,
                fog: 0x050510,
                treeColor: 0x00ffff,
                asphalt: '#1a1a1a',
                neon: true,
                pts: (r) => {
                    const p = [];
                    for (let i = 0; i < 32; i++) {
                        const t = (i / 32) * Math.PI * 2;
                        const x = Math.cos(t) * (r * 1.5) + Math.cos(t * 4) * 50;
                        const z = Math.sin(t) * r + Math.sin(t * 4) * 100;
                        const y = 0;
                        p.push(new THREE.Vector3(x, y, z));
                    }
                    return p;
                }
            }
        ];

        const CARS = [
            { name: "RED FIRE", color: 0xff4444, speed: 1.0, handle: 1.0 },
            { name: "BLUE JET", color: 0x4488ff, speed: 1.1, handle: 0.8 },
            { name: "SHADOW", color: 0x222222, speed: 0.9, handle: 1.2 }
        ];

        /**
         * STATE
         */
        let selectedCarIdx = 0;
        let selectedTrackIdx = 0;
        let gameState = 'menu'; // menu, countdown, racing, finished
        let clock, scene, camera, renderer;
        let trackCurve; // The THREE.Curve path
        let player = {
            mesh: null,
            progress: 0,
            offset: 0,
            speed: 0,
            maxSpeed: 0,
            accel: 0,
            lap: 1
        };
        let opponents = [];
        let obstacles = [];
        let scenery = [];
        let inputs = { left: false, right: false };

        /**
         * INIT
         */
        function selectCar(idx) {
            selectedCarIdx = idx;
            document.querySelectorAll('.car-option').forEach((el, i) => {
                el.classList.toggle('selected', i === idx);
            });
        }

        function selectTrack(idx) {
            selectedTrackIdx = idx;
            document.querySelectorAll('.track-option').forEach((el, i) => {
                el.classList.toggle('selected', i === idx);
            });
        }

        function startGame() {
            document.getElementById('menu-layer').style.display = 'none';
            document.getElementById('hud').style.display = 'flex';

            initThree();
            createTrack();
            createPlayer();
            createOpponents();
            createObstacles();
            createEnvironment();

            // Countdown
            gameState = 'countdown';
            document.getElementById('countdown-layer').style.display = 'flex';
            let count = 3;
            const el = document.getElementById('countdown');

            // Align camera before start
            updateCarPosition(player.mesh, 0, 0);
            updateCameraChase();

            const timer = setInterval(() => {
                count--;
                if (count > 0) {
                    el.innerText = count;
                } else if (count === 0) {
                    el.innerText = 'GO!';
                    el.style.color = '#ffcc00';
                } else {
                    clearInterval(timer);
                    document.getElementById('countdown-layer').style.display = 'none';
                    gameState = 'racing';
                    clock.start();
                }
            }, 1000);

            animate();
        }

        function initThree() {
            const track = TRACKS[selectedTrackIdx];
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(track.sky);
            scene.fog = new THREE.Fog(track.fog, 200, 1500);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting
            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemi);

            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(200, 400, 100);
            sun.castShadow = true;
            // High quality shadows for the track
            sun.shadow.mapSize.width = 4096;
            sun.shadow.mapSize.height = 4096;
            sun.shadow.camera.far = 1000;
            sun.shadow.camera.left = -600;
            sun.shadow.camera.right = 600;
            sun.shadow.camera.top = 600;
            sun.shadow.camera.bottom = -600;
            scene.add(sun);
        }

        /**
         * TRACK GENERATION
         */
        function createTrack() {
            const trackData = TRACKS[selectedTrackIdx];
            // 1. Create Curve Path
            const pts = trackData.pts(CONFIG.trackRadius);
            trackCurve = new THREE.CatmullRomCurve3(pts);
            trackCurve.closed = true;

            // 2. Create Custom Road Geometry
            const segments = 600;
            const roadGeo = new THREE.BufferGeometry();
            const positions = [];
            const uvs = [];
            const indices = [];
            const w = CONFIG.trackWidth;

            for (let i = 0; i < segments; i++) {
                const t = i / segments;
                const pt = trackCurve.getPointAt(t);
                const tan = trackCurve.getTangentAt(t).normalize();

                const up = new THREE.Vector3(0, 1, 0);
                const binormal = new THREE.Vector3().crossVectors(tan, up).normalize();

                const p1 = pt.clone().add(binormal.clone().multiplyScalar(-w));
                const p2 = pt.clone().add(binormal.clone().multiplyScalar(w));

                positions.push(p1.x, p1.y + 0.3, p1.z);
                positions.push(p2.x, p2.y + 0.3, p2.z);

                uvs.push(0, t * 60);
                uvs.push(1, t * 60);

                const base = i * 2;
                const nextBase = ((i + 1) % segments) * 2;

                indices.push(base, base + 1, nextBase);
                indices.push(base + 1, nextBase + 1, nextBase);
            }

            roadGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            roadGeo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            roadGeo.setIndex(indices);
            roadGeo.computeVertexNormals();

            // Texture for Road
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = trackData.asphalt;
            ctx.fillRect(0, 0, 512, 512);

            // Texture Detail
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            for (let i = 0; i < 8000; i++) ctx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);

            // Side Curbs
            const curbSize = 40;
            ctx.fillStyle = trackData.neon ? '#00ffff' : '#fff';
            ctx.fillRect(0, 0, curbSize, 512);
            ctx.fillRect(512 - curbSize, 0, curbSize, 512);

            ctx.fillStyle = trackData.neon ? '#ff00ff' : '#cc0000';
            for (let i = 0; i < 8; i++) {
                if (i % 2 == 0) {
                    ctx.fillRect(0, i * 64, curbSize, 32);
                    ctx.fillRect(512 - curbSize, i * 64, curbSize, 32);
                }
            }

            // Lane Lines
            ctx.fillStyle = trackData.neon ? 'rgba(0, 255, 255, 0.5)' : 'rgba(255, 255, 255, 0.8)';
            ctx.fillRect(250, 0, 12, 512);
            ctx.fillRect(80, 0, 4, 512);
            ctx.fillRect(427, 0, 4, 512);

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1, 1);

            const mat = new THREE.MeshStandardMaterial({
                map: tex,
                side: THREE.DoubleSide,
                roughness: 0.8,
                metalness: 0.1,
                emissive: trackData.neon ? new THREE.Color(0x222222) : new THREE.Color(0x000000)
            });

            const mesh = new THREE.Mesh(roadGeo, mat);
            mesh.receiveShadow = true;
            scene.add(mesh);

            createFinishLine();
        }

        function createFinishLine() {
            const pos = trackCurve.getPointAt(0);
            const tan = trackCurve.getTangentAt(0).normalize();
            const up = new THREE.Vector3(0, 1, 0);
            const side = new THREE.Vector3().crossVectors(tan, up).normalize();
            const w = CONFIG.trackWidth + 12;

            const group = new THREE.Group();

            const pillarGeo = new THREE.BoxGeometry(4, 38, 4);
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x444444 });

            const pLeft = new THREE.Mesh(pillarGeo, pillarMat);
            pLeft.position.copy(side.clone().multiplyScalar(-w));
            pLeft.position.y = 19;

            const pRight = new THREE.Mesh(pillarGeo, pillarMat);
            pRight.position.copy(side.clone().multiplyScalar(w));
            pRight.position.y = 19;

            const bannerGeo = new THREE.BoxGeometry(w * 2 + 5, 12, 3);
            const bannerMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const banner = new THREE.Mesh(bannerGeo, bannerMat);
            banner.position.y = 32;

            const cCanvas = document.createElement('canvas');
            cCanvas.width = 1024;
            cCanvas.height = 256;
            const cCtx = cCanvas.getContext('2d');
            cCtx.fillStyle = '#111';
            cCtx.fillRect(0, 0, 1024, 256);

            cCtx.fillStyle = '#fff';
            const size = 32;
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 32; x++) {
                    if ((x + y) % 2 === 0) cCtx.fillRect(x * size, y * size, size, size);
                }
            }

            cCtx.font = 'bold 120px Racing Sans One';
            cCtx.fillStyle = '#ffcc00';
            cCtx.textAlign = 'center';
            cCtx.fillText('START / FINISH', 512, 170);

            const cTex = new THREE.CanvasTexture(cCanvas);
            const textMat = new THREE.MeshBasicMaterial({ map: cTex, side: THREE.DoubleSide });
            const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(w * 2, 9), textMat);
            textMesh.position.set(0, 32, 0);

            group.add(pLeft); group.add(pRight); group.add(banner); group.add(textMesh);
            group.position.copy(pos);
            group.lookAt(pos.clone().add(tan));
            scene.add(group);
        }

        function createEnvironment() {
            const trackData = TRACKS[selectedTrackIdx];
            // Large Grass/Sand Floor
            const grassGeo = new THREE.PlaneGeometry(20000, 20000);
            const grassMat = new THREE.MeshStandardMaterial({
                color: trackData.ground,
                roughness: 1,
                metalness: 0
            });
            const grass = new THREE.Mesh(grassGeo, grassMat);
            grass.rotation.x = -Math.PI / 2;
            grass.position.y = -20; // Below track
            scene.add(grass);

            // Trees and Cacti / Buildings
            const objGeo = trackData.neon ? new THREE.BoxGeometry(20, 150, 20) : new THREE.ConeGeometry(5, 15, 8);
            const objMat = new THREE.MeshStandardMaterial({
                color: trackData.treeColor,
                emissive: trackData.neon ? trackData.treeColor : 0x000000,
                emissiveIntensity: trackData.neon ? 0.5 : 0
            });
            const trunkGeo = new THREE.CylinderGeometry(1, 1, 5);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

            for (let i = 0; i < 300; i++) {
                const t = Math.random();
                const pos = trackCurve.getPointAt(t);
                const tan = trackCurve.getTangentAt(t);
                const norm = new THREE.Vector3().crossVectors(tan, new THREE.Vector3(0, 1, 0)).normalize();

                const dist = 50 + Math.random() * 500;
                const side = Math.random() > 0.5 ? 1 : -1;

                const finalPos = pos.clone().add(norm.multiplyScalar(dist * side));
                finalPos.y = trackData.neon ? 50 : -10;

                const grp = new THREE.Group();
                const mesh = new THREE.Mesh(objGeo, objMat);

                if (!trackData.neon) {
                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                    trunk.position.y = 2.5;
                    mesh.position.y = 10;
                    grp.add(trunk);
                }

                grp.add(mesh);
                grp.position.copy(finalPos);

                const s = 1 + Math.random() * 2;
                grp.scale.set(s, s, s);

                scene.add(grp);
            }
        }

        /**
         * ENTITIES
         */
        function createPlayer() {
            const spec = CARS[selectedCarIdx];
            player.mesh = createCarMesh(spec.color);
            scene.add(player.mesh);

            player.maxSpeed = 180 * spec.speed;
            player.trackLen = trackCurve.getLength();
            player.accel = 100;
            player.turnSpeed = 25 * spec.handle;
        }

        function createOpponents() {
            const colors = [0xff0000, 0x00ff00, 0xffff00, 0xffaabb, 0x0000ff];
            for (let i = 0; i < CONFIG.aiCount; i++) {
                const ai = {
                    mesh: createCarMesh(colors[i % colors.length]),
                    progress: 0.01 + (i * 0.01),
                    offset: (Math.random() - 0.5) * (CONFIG.trackWidth * 0.8),
                    speed: 145 + Math.random() * 35, // More aggressive AI
                    laneBias: (Math.random() - 0.5) * 10
                };
                scene.add(ai.mesh);
                opponents.push(ai);
            }
        }

        function createObstacles() {
            const matRed = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const matOrange = new THREE.MeshStandardMaterial({ color: 0xffaa00 });

            for (let i = 0; i < 45; i++) {
                const group = new THREE.Group();
                const isEdge = i % 3 === 0; // 1/3 obstacles are on edges

                let o = (Math.random() - 0.5) * (CONFIG.trackWidth);
                if (isEdge) {
                    o = (Math.random() > 0.5 ? 1 : -1) * (CONFIG.trackWidth - 4);
                }

                if (isEdge) {
                    // Create a traffic cone / pylon for edges
                    const cone = new THREE.Mesh(new THREE.ConeGeometry(1.5, 4, 8), matOrange);
                    cone.position.y = 2;
                    group.add(cone);
                } else {
                    // Construct a barrier for the middle
                    const bar = new THREE.Mesh(new THREE.BoxGeometry(6, 1.5, 0.5), matRed);
                    bar.position.y = 2;
                    const leg1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 0.5), new THREE.MeshStandardMaterial({ color: 0x884400 }));
                    leg1.position.set(-2, 1.5, 0);
                    const leg2 = leg1.clone();
                    leg2.position.set(2, 1.5, 0);
                    group.add(bar); group.add(leg1); group.add(leg2);
                }

                const p = 0.15 + (i / 45) * 0.8 + (Math.random() * 0.05);
                const pt = trackCurve.getPointAt(p % 1);
                const tan = trackCurve.getTangentAt(p % 1);
                const normal = new THREE.Vector3().crossVectors(tan, new THREE.Vector3(0, 1, 0)).normalize();

                const pos = pt.clone().add(normal.multiplyScalar(o));
                group.position.copy(pos);
                group.lookAt(pos.clone().add(tan));
                scene.add(group);

                obstacles.push({
                    mesh: group,
                    progress: p % 1,
                    offset: o
                });
            }
        }

        function createCarMesh(color) {
            const grp = new THREE.Group();

            // Sports Car low poly
            const matBody = new THREE.MeshStandardMaterial({ color: color, metalness: 0.6, roughness: 0.2 });
            const matDark = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.5, roughness: 0.5 });
            const matWin = new THREE.MeshStandardMaterial({ color: 0x88ccff, metalness: 0.9, roughness: 0.1 });

            // Main Chassis
            const chassis = new THREE.Mesh(new THREE.BoxGeometry(3.6, 1.2, 7), matBody);
            chassis.position.y = 1.2;
            chassis.castShadow = true;
            grp.add(chassis);

            // Top Cabin
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(3.2, 1.0, 3.5), matWin);
            cabin.position.set(0, 2.2, -0.5);
            grp.add(cabin);

            // Spoiler
            const spoiler = new THREE.Mesh(new THREE.BoxGeometry(3.8, 0.2, 1), matBody);
            spoiler.position.set(0, 2.2, 3.2);
            grp.add(spoiler);

            // Wheels
            const wGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.8, 20);
            const wMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const pos = [
                [-1.8, 0.8, 2.0], [1.8, 0.8, 2.0],
                [-1.8, 0.8, -2.0], [1.8, 0.8, -2.0]
            ];
            pos.forEach(p => {
                const w = new THREE.Mesh(wGeo, wMat);
                w.rotation.z = Math.PI / 2;
                w.position.set(...p);
                w.castShadow = true;
                grp.add(w);
            });

            return grp;
        }

        /**
         * CONTROLS
         */
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft' || e.key === 'a') inputs.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd') inputs.right = true;
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft' || e.key === 'a') inputs.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd') inputs.right = false;
        });

        /**
         * GAME LOOP
         */
        function animate() {
            requestAnimationFrame(animate);

            if (gameState === 'racing') {
                const dt = Math.min(clock.getDelta(), 0.1);
                updateGame(dt);
            }

            renderer.render(scene, camera);
        }

        function updateGame(dt) {
            // Player Physics
            if (player.speed < player.maxSpeed) player.speed += player.accel * dt;

            let turn = 0;
            if (inputs.left) turn -= 1;
            if (inputs.right) turn += 1;

            player.offset += turn * player.turnSpeed * dt;
            const limit = CONFIG.trackWidth - 3;
            if (player.offset > limit) player.offset = limit;
            if (player.offset < -limit) player.offset = -limit;

            const dist = player.speed * dt;
            player.progress += dist / player.trackLen;

            if (player.progress >= 1) {
                player.progress -= 1;
                player.lap++;
                document.getElementById('hud-lap').innerText = `${player.lap}/${CONFIG.laps}`;
                if (player.lap > CONFIG.laps) endGame(true);
            }

            updateCarPosition(player.mesh, player.progress, player.offset);
            updateCameraChase();

            // Opponents
            opponents.forEach(ai => {
                ai.progress += (ai.speed / player.trackLen) * dt;
                if (ai.progress >= 1) ai.progress -= 1;
                updateCarPosition(ai.mesh, ai.progress, ai.offset);
            });

            // Collisions
            const pPos = player.mesh.position;
            const hitDist = 4;
            obstacles.forEach(obs => {
                // Rough proximity check via progress (careful with wrap-around)
                if (Math.abs(player.progress - obs.progress) < 0.02) {
                    if (pPos.distanceTo(obs.mesh.position) < hitDist) {
                        player.speed = 20; // Massive slowdown
                        // Shake camera
                        camera.position.x += (Math.random() - 0.5) * 2;
                        camera.position.y += (Math.random() - 0.5) * 2;
                    }
                }
            });

            // HUD
            document.getElementById('hud-speed').innerText = Math.floor(player.speed);

            // Rank
            let rank = 1;
            opponents.forEach(ai => {
                if (ai.progress > player.progress) rank++;
            });
            document.getElementById('hud-pos').innerText = `${rank}/${CONFIG.aiCount + 1}`;
        }

        function updateCarPosition(mesh, progress, offset) {
            const pt = trackCurve.getPointAt(progress % 1);
            const tan = trackCurve.getTangentAt(progress % 1).normalize();
            // Calculate banked up vector?
            // Simple: Just use Y axis as Global Up
            const up = new THREE.Vector3(0, 1, 0);
            const binormal = new THREE.Vector3().crossVectors(tan, up).normalize();

            const finalPos = pt.clone().add(binormal.multiplyScalar(offset));
            mesh.position.copy(finalPos);

            // Orientation
            const lookTarget = finalPos.clone().add(tan);
            mesh.lookAt(lookTarget);

            // Align to ground slope approx
            // We can check point ahead/behind to align X axis?
            // For now, simple lookAt is fine, but lets add banking for turns
            mesh.rotateZ(-offset * 0.015);
        }

        function updateCameraChase() {
            const camTarget = player.mesh.position.clone();
            const tan = trackCurve.getTangentAt(player.progress % 1).normalize();

            // Slightly higher and more angled down to see the street
            const camOffset = tan.clone().multiplyScalar(-38).add(new THREE.Vector3(0, 22, 0));

            camera.position.lerp(camTarget.clone().add(camOffset), 0.12);
            camera.lookAt(camTarget.clone().add(tan.multiplyScalar(25)));
        }

        function endGame(win) {
            gameState = 'finished';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('game-over-layer').style.display = 'flex';

            let rank = 1;
            opponents.forEach(ai => {
                if (ai.progress > player.progress) rank++;
            });

            document.getElementById('end-title').innerText = rank === 1 ? "¡VICTORIA!" : "¡BIEN JUGADO!";
            document.getElementById('end-title').style.color = rank === 1 ? "#00aa00" : "#ff4400";
            document.getElementById('end-msg').innerText = `Has terminado en la posición ${rank} de ${opponents.length + 1}.`;
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>